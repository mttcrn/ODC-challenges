# pkm
The goal is to read the flag, leveraging a poisoned null byte vulnerability.

## Context
The vulnerability is implemented in the following function:
```{c}
char *get_string(){
	uint32_t length = 0;
	while (length == 0)
	{
		printf("[.] insert length: ");
		if ( scanf("%u", &length) != 1){
			clear_stdin();
		}
	}
	char *s = malloc(length);
	uint32_t i = 0;
	for(i = 0; i < length; i++){
		read(STDIN_FILENO, &s[i], 1);
		if(s[i] == '\n'){
			break;
		}
	}
	s[i] = 0; //here there is a poisoned null byte
	return s;
}
```
which is then called by `rename_pkm`:
```{c}
void rename_pkm(){
	puts("[*] Rename PKM!");
	uint8_t coiche = get_pkm();
	if (pkms[coiche]->name && pkms[coiche]->name != UNKNOWN){
		free(pkms[coiche]->name);
	}
	pkms[coiche]->name = get_string();
}
```

## Approach
1st part: leak libc base address
- Allocates 3 PKMs to create memory chunks.
- Overwrites prev_inuse of chunk C by exploiting a null-byte overflow after freeing B.
- Frees C to merge chunks, enabling future chunk overlap.
- Overwrites the metadata of B2 to point to malloc@GOT and retrieves its address.
- Calculates libc base address using the leaked malloc address. 

2nd part: pop a shell
- Repeats the setup to create overlapping chunks: the idea is to set the move of a PKM to `system`
- Crafts a payload that overwrites a PKM name with /bin/sh and sets system as its move.
- Triggers a call to system("/bin/sh") via the fight_pkm function.
