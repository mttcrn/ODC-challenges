# fastbin_dup
The goal is to read the flag, leveraging a fastbin duplication attack.

## Context 
The challenge allows you to allocate, read and write in memory at address `entries`.

By inspecting the disassembled code in IDA it is possibile to derive the data structure:
```{c}
struct entries {
	char *buff;
	unsigned int buffer_size;
	int is_free_bool;
}
```
The alloc function works as follows:
```{c}
int alloc(){
	int i;
	int integer;
	for (i = 0; i <= 99 && entries[i].buff; ++i); //find the next free entry
	if (i == 100) //maximum length of the struct
		return puts("No more entries!");
	printf("Size: ")
	integer = read_integer("Size: ")
	if(integer > 0 && integer <= 4095){
		entroes[i].buf = integer;
		entries[i].buffer_size = malloc(integer);
		entries[i].is_free_bool = 0;
	}
	return printf("Allocated at index %d!\n", (unsigned int)i);
}
```
The write function works as follows:
```{c}
int write_entry(){
	unsigned int integer;
	printf("Index: ")
	integer = read_integer("Index: ");
	if(integer > 0x63){
		puts("Index out of range!");
	}
	if(entries[integer].is_free_bool){
		puts("Can't write on a freed entry!");
	}
	if(!entries[integer].buff){
		puts("Not allocated yet!");
	}
	printf("Content: ");
	read(0, entries[integer].buff, entries[integer].buffer_size);
	entries[integer].buff[entries[integer].buffer_size - 1] = '\0';
	return puts("Done!");
}
```
The read function works as follows:
```{c}
int read_entry(){
	unsigned int integer;
	printf("Index: ")
	integer = read_integer("Index: ");
	if(integer > 0x63){
		puts("Index out of range!");
	}
  //it is possibile to read the content of a free entry, since there is no check for is_free_bool
	if(entries[integer].buff){
		return puts(entries[integer].buff); 
	}
	return puts("Not allocated yet!");
}
```
The free function works as follows:
```{c}
int free_entry(){
	unsigned int integer;
	printf("Index: ")
	integer = read_integer("Index: ");
	if(integer > 0x63){
		return puts("Index out of range!");
	}
  // it is possibile to free twice the content of the same entry, since there is no check for is_free_bool
	free(entries[integer].buff); 
	entries[integer].is_free_bool = 1;
	return printf("Index %d freed!\n", integer);
}
```
## Approach
First of all, I had to leak the LIBC address using a freed chunck, in order to locate the `__malloc_hook` and the gadgets (since they are not fixed in memory).
 
Then I set up a fastbin dup attack, in order to overwrite the fastbin pointer with the `__malloc_hook` pointer:
- Generate a loop in the fastbin list by freeing two times the same chunck.
- Use this loop to retrieve the same chunk multiple times from the fastbin list via malloc.
- Modify the data of a chunck that is retreived form malloc but still resides in the fastbin list. This allows control to redirect future allocation from the fastbin freelist to `__malloc_hook`.

Another allocation is performed to overwrite the `__malloc_hook` with the address of a one-gadget ROP payload: this execute a shell when `malloc` is invoked. So the final step is to call `malloc` resulting in a spawned shell. 
