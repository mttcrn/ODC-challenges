import angr
import claripy


global values_addr 
values_addr = 0

#what will be executed instead of convert
class HookConvert(angr.SimProcedure):
  def run(self):
    global values_addr
    values = []
    for i in range(30):
      var = claripy.BVS(f'var{i}', 8) #symbolic bitvectorÃ¹
      #first char is symbolic, the rest are not
      fixed = claripy.BVV(0, 8 * 7) #non-symbolic bitvector
      self.state.solver.add(var >= 0)
      self.state.solver.add(var <= 61)
      values.append(var)
      values.append(fixed)
    symbolic_bv = claripy.Concat(*values)
    self.state.memory.store(values_addr, symbolic_bv) #address of values
    self.state.globals["symbolic_bv"] = symbolic_bv
    return 0


#create a project, disable the auto_load_libs since angr has a set of library functions that are optimized to be symbolically executed
project = angr.Project("./challenge", auto_load_libs = False) 

#provide an empty argument
initial_state = project.factory.entry_state(args=["./challenge", "AAAAAAAA"])
values_addr = project.loader.find_symbol("values").rebased_addr
project.hook_symbol("convert", HookConvert())

simulation = project.factory.simgr(initial_state)

#reach the point of the program where all conditions are satisfied (mov eax, 1)
#0x400000 is the base address in angr
simulation.explore(find=[0x400000 + 0x21C5], avoid=[0x400000 + 0x21CC]) #perform the simulaton

if simulation.found:
  found = simulation.found[0] #retreive first solution (there may be more)
  solution = found.solver.eval(found.globals["symbolic_bv"], cast_to = bytes)
  sol = b''
  for i in range(0, 30*8, 8):
    sol += solution[i].to_bytes(byte_order="little")
  print(sol)
